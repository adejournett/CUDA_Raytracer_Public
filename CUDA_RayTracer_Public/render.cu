#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <assert.h>
#include <float.h>

//cuda includes
#include <curand_kernel.h>
#include <thrust/random/linear_congruential_engine.h>
#include <thrust/random/uniform_real_distribution.h>

// CUDA helper functions
// Utilities and timing functions
#include <helper_functions.h>    // includes cuda.h and cuda_runtime_api.h
#include <helper_cuda.h>         // helper functions for CUDA error check
#include <vector_types.h>
#include"cuda_util.h"

#include"sampling.h"
#include"lambertian.h"
#include"cook_torrance.h"
#include"microfacet_single.h"
#include"microfacet_multiple.h"
#include"bssrdf_approx.h"
#include"bssrdf_dipole.h"
#include"surfel.h"
#include"sahtree.h"
#include"image.h"
#include"SDLManager.h"
#include"scene.h"
#include"pcdata.h"

//globals


/*
	This is the pathtracing function, meant to run via the GPU only
	This function uses an initial ray from the camera (eye) of the scene
	If that ray hits an object, the ray will bounce max_depth times within the scene
	color contribution is summed according to radiosity at each ray hit

	when max_bounces are exceeded, or the ray fails to hit an object, returns a float3 color in the range 0-1

	\param r, the ray generated by the camera
	\param world, the scene
	\param max_depth, maximum ray bounces
	\param t1, initial parametric value for the ray hit
	\param t2, secondary parametric value for the ray hit, used in transparent object color contribution

*/
__device__ float3 pathTrace(Ray &r, Scene **world, int max_depth, float t1, float t2)
{
	float3 color = make_float3(0.0f, 0.0f, 0.0f);
	int iter = 0;

	Ray ray = Ray(r.origin(), r.direction());
	for(iter = 0; iter < max_depth; ++iter)
	{
		HitRec rec;
		rec.hit_t = FLT_MAX;
		Surfel surf;
		if ((*world)->intersectTree(rec, ray, surf, t1, t2, true))
		{
			float3 hit_point = ray.point_at_parameter(rec.hit_t + 1e-6);
			float3 newDir = make_float3(0.0f, 0.0f, 0.0f);
			//gather direct light (assumes point lights only)
			for (int l = 0; l < (*world)->numLights; l++)
			{
				int numSamples = (*world)->lights[l].isArea ? 100 : 1;
				for (int sample = 0; sample < numSamples; ++sample)
				{
					//if out hit point isnt in shadow, compute the color
					float3 lightSample = (*world)->lights[l].position + Sampling::rand() * make_float3(16.0f, 0.0f, 0.0f) + Sampling::rand() * make_float3(0.0f, 8.0f, 0.0f);
					float3 toLight = lightSample - hit_point; //incident direction
					float dist_sq = length(toLight);
					toLight /= dist_sq;

					if ((*world)->lineOfSight(Ray(hit_point, toLight), dist_sq))
					{
						float3 w_i = toLight;
						//light intensity modulated by distance
						float3 irradiance = (*world)->lights[l].color;// / dist_sq;

						float3 w_o = normalize(ray.origin() - hit_point);
						//choose a material to use based on the material of the surfel the ray intersected
						float3 BSDF;
						if (surf.mat == 0)
						{
							Lambertian l = Lambertian(surf.material.albedo);
							BSDF = l.sampleBSDF(rec.normal, w_i, w_o);
						}
						else if (surf.mat == 1)
						{
							Cook_Torrance c = Cook_Torrance(surf.material.albedo, surf.material.roughness, surf.material.ks, surf.material.index);
							BSDF = c.sampleBSDF(rec.normal, w_i, w_o);
						}
						else if (surf.mat == 2 || surf.mat == 3)
						{
							BSSRDF_Approx b = BSSRDF_Approx(surf.material.albedo, surf.material.index, surf.material.extinction, surf.material.absorbtion, surf.material.scattering, surf.material.mean_cos);
							BSDF = b.sampleBSDF(rec.normal, w_i, w_o);
						}
						else if (surf.mat == 3)
						{
							BSSRDF_Dipole b = BSSRDF_Dipole(surf.material.albedo, surf.material.index, surf.material.extinction, surf.material.absorbtion, surf.material.scattering, surf.material.mean_cos);
							BSDF = b.sampleBSSRDF(rec.normal, w_i, w_o, hit_point);
						}
						else if (surf.mat == 4)
						{
							MicrofacetSingleScatter m;
							BSDF = make_float3(0.6f, 0.0f, 0.0f);
						}
						else if (surf.mat == 5)
						{
							MicrofacetMultipleScatter m;
							BSDF = make_float3(0.0f, 0.0f, 0.6f);
						}
						color += BSDF * irradiance * fmaxf(0.0f, dot(toLight, rec.normal)); //divide by nonscattering chance 
					}
					color += make_float3(0.35f, 0.35f, 0.35f) * surf.material.albedo;
				}
				color /= (float) numSamples;		
			}
		}
		else
		{
			break;
		}
	}
	return clamp(color / float(iter), 0.0f, 1.0f);
}


/*
	This is the rendering kernel, it does the main work of the program. 
	Early culls rays that do not hit the bounding box, otherwise calls the path tracing function to compute a color for the pixel

	Should be called keeping in mind that a thread is 16 warps to maintain maximum occupancy and prevent warp misalignment

	\param fb, the framebuffer. dimensions 3 * width * height
	\param world, the Scene object. stores camera used in generating rays. this obj is passed to the pathtracer since it also stores the SAH Tree
	\param max_depth, the maximum number of ray bounces	
*/
__global__ void render(unsigned char *fb, Scene **world, int max_depth) {
	/*
		Register guide
			3 ints			->	3 registers
			2 floats		->	2 registers
			1 float3		->	3 registers

			1 for loop		->	28 registers

			1 box intersection test -> 1 register
			1 ray creation	->	the rest of the registers? dunno. Would imply 55 registers... seems a bit obscene
	
			1 curandState*	->	8 bytes cmem[0] (if you put this in shared memory you get an aliasing bug due to caching)

		total registers:		92 (31% occupancy)
		without loop:			64 (50% occupancy) 352 bytes cmem[0], 24 bytes cmem[2], ~58 FPS
		without loop or root intersection test: 62 (50% occupancy, but much slower) 352 bytes cmem[0], 20 bytes cmem[2]

		without loop, limiting to 32 registers:	(100% occupancy), terrible frame rate. 

		memory guide:
			cmem is constant memory, no idea what the indexes are. 
			smem is shared memory


		using 8x8 instead of 1x64 thread block gives an extra 15 FPS. Definitely due to spatially based caching

	*/
	int i, j, pixel_index;
	float t1, t2;
	float3 color;

	i = threadIdx.x + blockIdx.x * blockDim.x;
	j = threadIdx.y + blockIdx.y * blockDim.y;
	if ((i >= (*world)->camera->height) || (j >= (*world)->camera->width)) //if we exceed the image pixel bounds
		return;
	pixel_index = 3 * ((*world)->camera->width * (*world)->camera->width - (j * (*world)->camera->width) + i); //convert 2D indexing to 1D for image

	color = make_float3(0.0f, 0.0f, 0.0f); //initial color is black.
	
	//linear congruential generator used for antialiasing
	//this generator is the fastest for a GPU context
	thrust::minstd_rand rng;
	thrust::uniform_real_distribution<float> dist(0.0f, 1.0f); // thrust::uniform_real_distribution<float>(0.0f, 1.0f);
	
	t1 = 0.0f; //ray hit position 1
	t2 = FLT_MAX; //ray hit position 2 (used for transparent objects)
	Ray r; 
	//4 registers for the intersection test, but if we disable it the overall FPS goes down
	//int iters = 1;
	//for (int k = 0; k < iters; k++)
	//{
		r = (*world)->camera->computeEyeRay(i + 0.5f, j + 0.5f);
		if (!(*world)->boxes[1].intersect(r, t1, t2)) //intersect ray with root node's AABB, if false we missed the scene container
		{
			fb[pixel_index] = 0; //set pixel to black, no ray hit
			fb[pixel_index + 1] = 0;
			fb[pixel_index + 2] = 0;
			return;
		}
		else
		{
			color += pathTrace(r, world, max_depth, t1, t2);
		}
	//}
	//clamp colors and convert from 0-1 range to 0-255 range
	color = clamp(color, 0.0f, 1.0f);
	fb[pixel_index] = int(255.99*color.x);
	fb[pixel_index + 1] = int(255.99*color.y);
	fb[pixel_index + 2] = int(255.99*color.z);
}

/*
	Kernel used for filling in data of the Scene obj.
	This must be done on the kernel in device space according to CUDA specifications

	\param world, the scene object, stores light, camera, and SAHTree type data
	\param light, array of lights in the scene
	\param tree, Flattened SAHTree, stored in device memory
	\param boxes, Flattened AABB corresponding to the Nodes of the SAHTree
	\param ropes, Flattened Rope corresponding to the Nodes of the SAHTree
	\param size, number of nodes in the tree
	\param width, image width
	\param height, image height
	\param numSurfels, number of surfels in the scene
	\param dynamic cam, control variable for camera creation, determines if the camera was specified in the file or should be computed dynamically
	\param dynamicLight, same idea as dynamicCam
	\param lightPos, lightPosition if light was specified in the file
	\param camPos, same as lightPos
	\param lookAt, same as camPos/lightPos	
*/
__global__ void create_world(Scene **world, Light *light, SAHGPUNode *tree, AABB *boxes, Surfel *surfels, Rope *ropes, int size, int WIDTH, int HEIGHT, int numSurfels, bool dynamicCam, bool dynamicLight, float3 lightPos, float3 camPos, float3 lookat)
{
	if (threadIdx.x == 0 && blockIdx.x == 0)
	{
		Camera *camera;

		if (dynamicCam) //if the scene file doesn't explicitly specify a camera
		{
			float3 midpoint = (boxes[1].min + boxes[1].max) / 2;
			float3 eye = midpoint;
			eye.z = boxes[1].min.z - (length(boxes[1].min - boxes[1].max) / 100.0f);
			camera = new Camera(eye, midpoint, make_float3(0.0f, 1.0f, 0.0f), 60.0f, WIDTH, HEIGHT);
			
		}
		else
		{
			camera = new Camera(camPos, lookat, make_float3(0.0f, 1.0f, 0.0f), 60.0f, WIDTH, HEIGHT);
		}

		if (dynamicLight)
			light[0] = Light(camera->eye, make_float3(0.8f, 0.8f, 0.8f), make_float3(16.0f, 0.0f, 0.0f), make_float3(0.0f, 8.0f, 0.0f), false);
		else
			light[0] = Light(lightPos, make_float3(0.8f, 0.8f, 0.8f), make_float3(16.0f, 0.0f, 0.0f), make_float3(0.0f, 8.0f, 0.0f), false);

		//finalize world

		*world = new Scene(light, 1, camera, surfels, tree, boxes, ropes, size, numSurfels);
	}

}

/*
	CUDA Kernel for debug ray casting. Casts a single ray at the center of a pixel.
	
	NOTE: should only be used in debugging. The extra register count and overhead for 2 kernels is a bad idea to use in the render kernel.
*/
__global__ void castSingleRay(Scene **world, int x, int y)
{
	Ray r = (*world)->camera->computeEyeRay((float)x + 0.5f, (float)y + 0.5f);
	float t_entry = 0.0f;
	float t_exit = FLT_MAX;
	HitRec rec;
	Surfel surf;
	if ((*world)->boxes[1].intersect(r, t_entry, t_exit))
		(*world)->intersectTree(rec, r, surf, t_entry, t_exit, false);
	else
		printf("Miss Tree\n");
}

/*
	Simple interface for casting a single ray with a mouse click. Used in the UI event handlers
*/
void cudaCastSingleRay(Scene **world, int x, int y)
{
	castSingleRay << <1, 1 >> > (world, x, y);
}


/*
	This is a debugging function that does a BFS traversal of the flattened SAH-Tree 
	Prints debug data to std::out

*/
__global__ void print_gpu(KDNode *d_tree, Surfel *surfels, AABB *boxes, int arr_size)
{
	printf("Minbox: (%f, %f, %f)\n", boxes[1].min.x, boxes[1].min.y, boxes[1].min.z);
	printf("Maxbox: (%f, %f, %f)\n", boxes[1].max.x, boxes[1].max.y, boxes[1].max.z);
	for (int i = 0; i < arr_size; i++)
	{
		printf("Index: %d\n", i);
		if (d_tree[i].split_axis == -1)
		{
			printf("Nonexistent node\n\n");
			continue;
		}
		
		printf("Node Properties: \n");
		printf("\tAxis: %d\n\tSplit Pos: %f\n", d_tree[i].split_axis, d_tree[i].split_pos);

		printf("Surfel Properties: \n");
		printf("\tSurfels: %d\n", d_tree[i].numSurfels);

		if (d_tree[i].numSurfels > 0)
		{
			for (int j = 0; j < d_tree[i].numSurfels; j++)
			{
				printf("\t(%f, %f, %f)\n", surfels[d_tree[i].surfels[j]].point.x, surfels[d_tree[i].surfels[j]].point.y, surfels[d_tree[i].surfels[j]].point.z);
			}
		}

		printf("AABB Properties: \n");
		printf("\tX:%f~%f\n", boxes[i].min.x, boxes[i].max.x);
		printf("\tY:%f~%f\n", boxes[i].min.y, boxes[i].max.y);
		printf("\tZ:%f~%f\n", boxes[i].min.z, boxes[i].max.z);
		
		if (d_tree[i].numSurfels > 0)
		{
			printf("Rope Properties: \n");
			printf("\tLeft[%d]: X:%f~%f\tY:%f~%f\tZ:%f~%f\n", d_tree[i].ropes[0], boxes[d_tree[i].ropes[0]].min.x, boxes[d_tree[i].ropes[0]].max.x, boxes[d_tree[i].ropes[0]].min.y, boxes[d_tree[i].ropes[0]].max.y, boxes[d_tree[i].ropes[0]].min.z, boxes[d_tree[i].ropes[0]].max.z);
			printf("\tDown[%d]: X:%f~%f\tY:%f~%f\tZ:%f~%f\n", d_tree[i].ropes[1], boxes[d_tree[i].ropes[1]].min.x, boxes[d_tree[i].ropes[1]].max.x, boxes[d_tree[i].ropes[1]].min.y, boxes[d_tree[i].ropes[1]].max.y, boxes[d_tree[i].ropes[1]].min.z, boxes[d_tree[i].ropes[1]].max.z);
			printf("\tBack[%d]: X:%f~%f\tY:%f~%f\tZ:%f~%f\n", d_tree[i].ropes[2], boxes[d_tree[i].ropes[2]].min.x, boxes[d_tree[i].ropes[2]].max.x, boxes[d_tree[i].ropes[2]].min.y, boxes[d_tree[i].ropes[2]].max.y, boxes[d_tree[i].ropes[2]].min.z, boxes[d_tree[i].ropes[2]].max.z);
			printf("\tRight[%d]: X:%f~%f\tY:%f~%f\tZ:%f~%f\n", d_tree[i].ropes[3], boxes[d_tree[i].ropes[3]].min.x, boxes[d_tree[i].ropes[3]].max.x, boxes[d_tree[i].ropes[3]].min.y, boxes[d_tree[i].ropes[3]].max.y, boxes[d_tree[i].ropes[3]].min.z, boxes[d_tree[i].ropes[3]].max.z);
			printf("\tUp[%d]: X:%f~%f\tY:%f~%f\tZ:%f~%f\n", d_tree[i].ropes[4], boxes[d_tree[i].ropes[4]].min.x, boxes[d_tree[i].ropes[4]].max.x, boxes[d_tree[i].ropes[4]].min.y, boxes[d_tree[i].ropes[4]].max.y, boxes[d_tree[i].ropes[4]].min.z, boxes[d_tree[i].ropes[4]].max.z);
			printf("\tFront[%d]: X:%f~%f\tY:%f~%f\tZ:%f~%f\n", d_tree[i].ropes[5], boxes[d_tree[i].ropes[5]].min.x, boxes[d_tree[i].ropes[5]].max.x, boxes[d_tree[i].ropes[5]].min.y, boxes[d_tree[i].ropes[5]].max.y, boxes[d_tree[i].ropes[5]].min.z, boxes[d_tree[i].ropes[5]].max.z);
		}
		

		printf("\n");
	}
}

/*
	Wrapper for the print_gpu debug kernel
*/
void print_gpuw(KDNode *d_tree, Surfel *surfels, AABB *boxes, int arr_size)
{
	print_gpu << <1, 1 >> > (d_tree, surfels, boxes, arr_size);
}


/*
	CUDA kernel to interface between the host UI and the GPU memory which stores the camera. 
	Modifies the camera position by translating the eye and lookat position
*/
__global__ void change_cam(Scene **world, float3 eyetrans, float3 lookattrans)
{
	int w = (*world)->camera->width;
	int h = (*world)->camera->height;
	(*world)->camera = new Camera((*world)->camera->eye + eyetrans, (*world)->camera->lookat + lookattrans, make_float3(0.0f, 1.0f, 0.0f), 60.0f, w, h);
	(*world)->lights[0] = Light((*world)->camera->eye, make_float3(0.8f, 0.8f, 0.8f), make_float3(0.0f, 0.0f, 0.0f), make_float3(0.0f, 0.0f, 0.0f), false);
}

/*
	This is an implementation of the Trackball camera seen in Edward Angel's "Computer Graphics with OpenGL"
	Simulates a great-circle by computing mouse movement position, then rotates the camera about the great-circle. 

*/
__global__ void change_cam_mouse(Scene **world, float angle, float3 axis)
{
	int w = (*world)->camera->width;
	int h = (*world)->camera->height;
	float3 old = (*world)->camera->eye;
	float3 eye = make_float3(0.0f, 0.0f, 0.0f);
	float sinT = sinf(angle);
	float cosT = cosf(angle);
	//translate by -lookat (to origin)
	old -= (*world)->camera->lookat;

	//apply rotation
	eye.x = old.x * (cosT + powf(axis.x, 2) * (1 - cosT)) + old.y * (axis.x * axis.y * (1 - cosT) - axis.z * sinT) + old.z * (axis.x * axis.z * (1 - cosT) + axis.y * sinT);
	eye.y = old.x * (axis.x * axis.y * (1 - cosT) + axis.z * sinT) + old.y * (cosT + powf(axis.y, 2) * (1 - cosT)) + old.z * (axis.y * axis.z * (1 - cosT) - axis.x * sinT);
	eye.z = old.x * (axis.x * axis.z * (1 - cosT) - axis.y * sinT) + old.y * (axis.y * axis.z * (1 - cosT) + axis.x * sinT) + old.z *  (cosT + powf(axis.z, 2) * (1 - cosT));

	//translate back to lookat
	eye += (*world)->camera->lookat;

	//recreate camera and light to avoid GPU texture memory error
	(*world)->camera = new Camera(eye, (*world)->camera->lookat, make_float3(0.0f, 1.0f, 0.0f), 60.0f, w, h);
	(*world)->lights[0] = Light((*world)->camera->eye, make_float3(0.8f, 0.8f, 0.8f), make_float3(0.0f, 0.0f, 0.0f), make_float3(0.0f, 0.0f, 0.0f), false);
}

/*
	wrapper function to call the create_world kernel
*/
void launch_scene_kernel(Scene **d_world, SAHGPUNode *arr, AABB *boxes, Surfel *surfels, Rope *ropes, Light *light, int arr_size, SceneData data)
{
	clock_t start, stop;
	start = clock();

	//begin world creation
	cudaGetLastError();
	cudaDeviceSynchronize();
	std::cerr << "Creating world... " << "\n";
	float3 lightPos, camPos, lookat;
	if (data.dynamicCam)
	{
		camPos = make_float3(0.0f, 0.0f, 0.0f);
		lookat = make_float3(0.0f, 0.0f, 0.0f);
	}
	else
	{
		camPos = data.camPos;
		lookat = data.lookat;
	}

	if (data.dynamicLight)
	{
		lightPos = make_float3(0.0f, 0.0f, 0.0f);
	}
	else
	{
		lightPos = data.lights[0].position;
	}
	create_world << <1, 1 >> > (d_world, light, arr, boxes, surfels, ropes, arr_size, data.width, data.height, data.numVerts, data.dynamicCam, data.dynamicLight, lightPos, camPos, lookat);
	cudaGetLastError();
	cudaDeviceSynchronize();

	//timing for world creation
	stop = clock();
	double timer_seconds = ((double)(stop - start)) / CLOCKS_PER_SEC;
	std::cerr << "Created World: " << timer_seconds << "\n";
	std::cerr << "Num Surfels: " << data.numVerts << "\n";
}

/*
	Initializes the framebuffer in unified memory for the UI 
*/
unsigned char *init_fb(int w, int h)
{
	unsigned char *data;
	cudaMallocManaged((void **)&data, sizeof(unsigned char) * w * h * 3);
	checkCudaErrors(cudaDeviceSynchronize());
	return data;
}

/*
	Wrapper function to call the render kernel

	\param d_world, the scene
	\param data, the framebuffer
	\param w, image width
	\param h, image height
	\param x, image x block (used in warp calculation)
	\param y, image x block (used in warp calculation)
*/
int cudaRedraw(Scene **d_world, unsigned char *data, int w, int h, int x, int y)
{
	dim3 blocks(w / x, h / y);
	dim3 threads(x, y);
	int max_depth = 1;
	cudaMemset(data, 0, w * h * sizeof(unsigned char));
	checkCudaErrors(cudaDeviceSynchronize());
	render << <blocks, threads >> > (data, d_world, max_depth);
	checkCudaErrors(cudaGetLastError());
	checkCudaErrors(cudaDeviceSynchronize());

	return w * h * (max_depth * 2); //multiply by 2 to account for shadow rays
}

/*
	wrapper to change_cam kernel, corresponds to translation via moving the camera from WASD
*/
void cudaChangeCam(Scene **world, const float3 &eyetrans, const float3 &lookattrans)
{
	change_cam << <1, 1 >> > (world, eyetrans, lookattrans);
	checkCudaErrors(cudaDeviceSynchronize());
}


/*
	wrapper to chane_cam_mouse kernel, corresponds to angular rotation from dragging the mouse
*/
void cudaChangeCamMouse(Scene **world, float angle, const float3 &axis)
{
	change_cam_mouse << <1, 1 >> > (world, angle, axis);
	checkCudaErrors(cudaDeviceSynchronize());
}